Clam
====

Clam is a language that is designed to give the programmer the tools they need
to get the job done, without getting in their way. It attempts to offer
flexibility everywhere it can, and tries to stay out of the way of the
development process. It exists as nothing more than a tool to accomplish
some task, rather than a lifestyle one must adopt.

Features
========

    - Compiled to x86 assembly
        - This is done terribly, with zero optimizations
        - Transitioning to LLVM would be a wonderful and gigantic effort
    - Statically typed
    - Interfaces, in the style of Go (static duck typing)
    - Simple templating
        - Functions and data structures can be templated over one or more types
        - Not a Turing-complete mess, for better or worse
        - Not as powerful as D
        - Literally just type templating
    - Message passing concurrency system, in the style of Go
        - This is N:1 scheduling, not M:N: Sorry, only one OS thread of
          execution
    - Tuples
        - Can be created and unpacked with simple syntax
    - Functions can return tuples as well as single values
    - No exceptions
        - No exceptions
    - D-style scope statements
        - Blocks of code whose execution is deferred to the end of its
          enclosing function's scope
        - MAYBE: Maybe also could depend on the result of a boolean expression,
          evaluated at the time of potential execution (would require everything
          involved in the expression being valid both in the scope of scope
          statement declaration and potential execution, so probably only things
          valid within the outermost scope of the function)
    - Structs, in the style of D
        - Methods can be defined for structs inside the struct body
        - No inheritance
    - Sum types, in the style of OCaml
        - Types within each type constructor can be named, for code-as-docs
    - Pattern matching
        - Can pattern match on simple values
        - Can pattern match on tuples, with implicit unpacking
        - Can pattern match on type constructors for sum types
        - Can pattern match on arbitrarily complex boolean expressions, making
          match also operate as alternative syntax for complex if-elsif blocks
    - Maybe type
    - Uniform Function Call Syntax, heavy nod to D
    - Primitive dynamic arrays that know their length
        - No support for static arrays
    - Primitive associative arrays (hash maps), in the style of D
    - Primitive sets
        - Set operations are defined:
            - Union over two sets
            - Intersection over two sets
            - Others
    - Uniform 'in' operator that can check membership within:
        - Dynamic arrays
        - Associative arrays
            - Checks for existence of a key
        - Sets
        - For each, for user-defined data-types they must conform to an 'in'
          operator interface, probably some sort of equals() interface
    - Reference and constant are the only two function-parameter storage classes
    - Post-execution "return" blocks
        - Where regardless of the return statement that executes to return from
          a function, this block is entered, the generated return value is
          available, and any tweaking desired is possible on the return value
    - Function pointers
    - Closures
    - Both style of function pointers are treated as values that can be passed
      around and stored as with any other value type
    - MAYBE: Attempt to be at least somewhat compatible with the C ABI, in that
      the effort is minimized to utilize C code. Being able to call C is
      probably not that difficult, but making C able to call Clam code would
      require hand-holding of function signatures to ensure the right thing is
      done, since Clam supports returning tuples

