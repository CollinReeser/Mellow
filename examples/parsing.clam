func parse(tokenIn: chan!(Token))
{
    foreach (tok; tokenIn)
    {
        match (tok)
        {
            L_Paren:
                pass;
            Integer as (num):
                pass;
        }
    }
}

func tokenize(source: string, tokenOut: chan!(Token))
{
    dumbTokens := source.dumbSplit();
    foreach (tok; dumbTokens)
    {
        match (tok)
        {
            "(":
                tokenOut <- Token.L_Paren;
            ")":
                tokenOut <- Token.R_Paren;
            "if":
                tokenOut <- Token.If;
            with "^[1-9][0-9]*$".match(tok):
                tokenOut <- Token.Integer(tok);
            with "^[a-zA-Z_][a-zA-Z0-9_]*$".match(tok):
                tokenOut <- Token.Identifier(tok);
        }
    }
}

func dumbSplit(source: string): []string
{
    tokens: []string;
    index: ulong = 0;
    end: ulong = 1;
    len := source.length;
    while (index < len)
    {
        match (source[index] as ch)
        {
            with `^\s+$`.match(ch):
                index += 1;
            with ch in ['(', ')', '{', '}', '[', ']', ';', ':', '?', '~']:
                tokens ~= [ch.to!(string)];
                index += 1;
            with ch in ['`', '"', '\'']:
                tokens ~= [ch.to!(string)];
                index += 1;
            '<':
                if (index + 1 < len && source[index+1] in ['=', '-'])
                {
                    tokens ~= [source[index..index+2]];
                    index += 2;
                }
                else
                {
                    tokens ~= [ch.to!(string)];
                    index += 1;
                }
            '>':
                if (index + 1 < len && source[index+1] == '=')
                {
                    tokens ~= [source[index..index+2]];
                    index += 2;
                }
                else
                {
                    tokens ~= [ch.to!(string)];
                    index += 1;
                }
            with "[a-zA-Z_]".match(ch):
                token := ch.to!string;
                while (index + 1 < len && "[a-zA-Z0-9_]".match(source[index+1]))
                {
                    index += 1;
                    token ~= source[index];
                }
                tokens ~= token;
                index += 1;
            with "[1-9]".match(ch):
                token := ch.to!string;
                while (index + 1 < len && "[0-9]".match(source[index+1]))
                {
                    index += 1;
                    token ~= source[index];
                }
                tokens ~= token;
                index += 1;
        }
    }
}
