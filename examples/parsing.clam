func parse(tokenIn: chan!(Token))
{
    foreach (tok; tokenIn)
    {
        match (tok)
        {
            | L_Paren ::
                pass;
            | Integer(num) ::
                pass;
        }
    }
}

func tokenize(source: string, tokenOut: chan!(Token))
{
    dumbTokens := source.dumbSplit();
    foreach (tok; dumbTokens)
    {
        match (tok)
        {
            when "(" ::
                tokenOut <-= Token.L_Paren;
            when ")" ::
                tokenOut <-= Token.R_Paren;
            when "if" ::
                tokenOut <-= Token.If;
            when "^[1-9][0-9]*$".match(tok) ::
                tokenOut <-= Token.Integer(tok);
            when "^[a-zA-Z_][a-zA-Z0-9_]*$".match(tok) ::
                tokenOut <-= Token.Identifier(tok);
        }
    }
}

func dumbSplit(source: string): []string
{
    tokens: []string;
    index: ulong = 0;
    end: ulong = 1;
    len := source.length;
    while (index < len)
    {
        match (source[index] as ch)
        {
            when `^\s+$`.match(ch) ::
                index += 1;
            when ch in ['(', ')', '{', '}', '[', ']', ';', ':', '?', '~'] ::
                tokens ~= [ch.to!string];
                index += 1;
            when ch in ['`', '"', '\''] ::
                tokens ~= [ch.to!string];
                index += 1;
            when '<' ::
                if (index + 1 < len && source[index+1] in ['=', '-'])
                {
                    tokens ~= [source[index..index+2]];
                    index += 2;
                }
                else
                {
                    tokens ~= [ch.to!string];
                    index += 1;
                }
            when '>' ::
                if (index + 1 < len && source[index+1] == '=')
                {
                    tokens ~= [source[index..index+2]];
                    index += 2;
                }
                else
                {
                    tokens ~= [ch.to!string];
                    index += 1;
                }
            when "[a-zA-Z_]".match(ch) ::
                token := ch.to!string;
                while (index + 1 < len && "[a-zA-Z0-9_]".match(source[index+1]))
                {
                    index += 1;
                    token ~= source[index];
                }
                tokens ~= token;
                index += 1;
            when "[1-9]".match(ch) ::
                token := ch.to!string;
                while (index + 1 < len && "[0-9]".match(source[index+1]))
                {
                    index += 1;
                    token ~= source[index];
                }
                tokens ~= token;
                index += 1;
        }
    }
}
