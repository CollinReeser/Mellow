Program :: ( Variant
           | StructDef
           | FuncDef
           | InterfaceDef
           )+
           ;

Sp :: /\s+/;

StructDef :: #'struct' #Sp Identifier TemplateTypeParams StructBody;
StructBody :: #"{" (StructEntry | StructFunction)+ #"}";
StructEntry :: VariableTypePair #";";
StructFunction :: FuncDef;

FuncDef :: FuncSignature FuncBodyBlocks;
FuncSignature :: #'func' #Sp Identifier TemplateTypeParams FuncDefArgList FuncReturnType;
FuncDefArgList :: #"(" (FuncSigArg (#"," FuncSigArg)*)? #")";
FuncSigArg :: Identifier #":" ^StorageClass* TypeId;
FuncReturnType :: (#":" (TypeId | TypeTuple))?;
FuncBodyBlocks :: ( BareBlock
                  | (InBlock? OutBlock? ReturnModBlock? BodyBlock)
                  );
InBlock :: #"in" BareBlock;
OutBlock :: #"out" BareBlock;
ReturnModBlock :: #'return' ((#Sp Identifier) | (#"" IdTuple))? BareBlock;
BodyBlock :: #"body" BareBlock;

BareBlock :: #"{" Statement* #"}";

StorageClass :: RefClass
              | ConstClass
              ;
RefClass :: #'ref' #Sp;
ConstClass :: #'const' #Sp;

Variant :: #'variant' #Sp Identifier TemplateTypeParams VariantBody;
VariantBody ::  #"{" VariantEntry+ #"}";
VariantEntry :: #"|" Identifier VariantVarDeclList? #","?;
VariantVarDeclList :: #"(" VariantSubType (#"," VariantSubType)* #")";
VariantSubType :: VariableTypePair
                | Identifier
                ;

InterfaceDef :: #'interface' #Sp Identifier TemplateTypeParams InterfaceBody;
InterfaceBody :: #"{" InterfaceEntry+ #"}";
InterfaceEntry :: FuncSignature #";";

Statement :: BareBlock
           | FuncDef
           | (ReturnStmt #";")
           | IfStmt
           | WhileStmt
           | ForStmt
           | ForeachStmt
           | MatchStmtGeneral
           | MatchStmtVariant
           | (Declaration #";")
           | (SpawnStmt #";")
           | (YieldStmt #";")
           | (ChanWrite #";")
           | (BooleanExpr #";")
           ;

ReturnStmt :: #'return' #Sp BooleanExpr;

IfStmt :: #"if" #"(" BooleanExpr #")" BareBlock (ElseIfStmt)* ElseStmt?;
ElseIfStmt :: #'else' #Sp #"if" #"(" BooleanExpr #")" BareBlock;
ElseStmt :: #"else" BareBlock;

WhileStmt :: #"while" #"(" BooleanExpr #")" BareBlock;

ForStmt :: #"for" #"(" ForInit ForConditional ForPostStatement #")"
           #"{" Statement* #"}"
           ;
ForInit :: ( DeclTypeInfer
           | DeclAssignment
           | AssignExisting
           )?
           #";"
           ;
ForConditional :: BooleanExpr? #";";
ForPostStatement :: BooleanExpr?;

ForeachStmt :: #"foreach" #"(" ForeachArgs #";" BooleanExpr #")"
               #"{" Statement* #"}"
               ;
ForeachArgs :: Identifier (#"," Identifier)*;

Declaration :: VariableTypePair | DeclAssignment | DeclTypeInfer;

SpawnStmt :: #'spawn' #Sp FuncCall;

YieldStmt :: #'yield' #Sp;

ChanWrite :: BooleanExpr #"<-=" BooleanExpr;








BooleanExpr :: CommaOp;
CommaOp :: AssignmentOp (#"," AssignmentOp)*;
AssignmentOp :: DeclAssignment
              | DeclTypeInfer
              | AssignExisting
              | OrTest
              ;
DeclTypeInfer :: Identifier #":=" OrTest;
DeclAssignment :: VariableTypePair #"=" OrTest;
AssignExisting :: Identifier ^AssignExistingOp OrTest;
AssignExistingOp :: "="
                  | "+="
                  | "-="
                  | "/="
                  | "*="
                  | "%="
                  | "~="
                  ;
OrTest :: AndTest (#"||" AndTest)*;
AndTest :: NotTest (#"&&" NotTest)*;
NotTest :: (#"!" NotTest) | Comparison;
Comparison :: Expr (^CompOp Expr)*;
CompOp :: "<="
        | ">="
        | ('<' #Sp)
        | ('>' #Sp)
        | "=="
        | "!="
        | "<|>"
        | "<&>"
        | "<^>"
        | "<->"
        | "<in>"
        | ('in' #Sp)
        ;
Expr :: OrExpr;
OrExpr :: XorExpr (#"|" XorExpr)*;
XorExpr :: AndExpr (#"^" AndExpr)*;
AndExpr :: ShiftExpr (#"&" ShiftExpr)*;
ShiftExpr :: SumExpr (("<<" | ">>") SumExpr)*;
SumExpr :: ProductExpr (("+" | "-" | "~") ProductExpr)*;
ProductExpr :: Value (("*" | "/" | "%") Value)*;
Value :: (BooleanLiteral Trailer?)
       | Lambda
       | (CharLit Trailer?)
       | (StringLit Trailer?)
       | (CharRange Trailer?)
       | (IntRange Trailer?)
       | (ExprCast Trailer?)
       | (ParenExpr Trailer?)
       | (ArrayLiteral Trailer?)
       | (Number Trailer?)
       | SliceLengthSentinel
       | (ChanRead Trailer?)
       | (Identifier Trailer?)
       ;

BooleanLiteral :: ("true" #Sp)
                | ("false" #Sp)
                ;

Lambda :: #"func" LambdaArgs #"=>" (BareBlock | BooleanExpr);
LambdaArgs :: #"(" (VariableTypePair (#"," VariableTypePair)*)? #")";

CharRange :: CharLit #".." CharLit;
IntRange :: IntNum #".." IntNum;

ExprCast :: #"cast" #"(" TypeId #")";

ParenExpr :: #"(" BooleanExpr #")";

ArrayLiteral :: #"[" Value (#"," Value)* #"]";

Number :: FloatNum | IntNum;
CharLit :: /'(?:\\.|[^'\\])'/;
StringLit :: /"(?:\\.|[^"\\])*"/ | /\x60(?:[^\x60]*)\x60/;
IntNum :: /-?[1-9][0-9]*|0/;
FloatNum :: /-?[0-9]+\.[0-9]+/;

SliceLengthSentinel :: #"$";

ChanRead :: #"<-" BooleanExpr;

Atom :: Identifier Trailer?;
Trailer :: DynArrAccess
         | TemplateInstanceMaybeTrailer
         | FuncCall
         | MemberAccess
         ;
DynArrAccess :: Slicing Trailer?;
TemplateInstanceMaybeTrailer :: TemplateInstantiation Trailer?;
FuncCall :: FuncCallArgList Trailer?;
MemberAccess :: DotAccess Trailer?;
Slicing :: #"["
                ( IndexRange
                | SingleIndex
                )
           #"]"
           ;
SingleIndex :: BooleanExpr;
IndexRange :: StartToIndexRange
            | IndexToIndexRange
            | IndexToEndRange
            ;
StartToIndexRange :: #".." BooleanExpr;
IndexToEndRange :: BooleanExpr #"..";
IndexToIndexRange :: BooleanExpr #".." BooleanExpr;
FuncCallArgList :: #"(" (BooleanExpr (#"," BooleanExpr)*)? #")";
DotAccess :: #"." Atom;








MatchStmtGeneral :: #"match" #"(" MatchExpressions #")" #"{" MatchWhen+ #"}";
MatchExpressions :: (
                      MatchExpr
                      (#"," MatchExpr)*
                    )?
                     ;
MatchExpr :: BooleanExpr (#"as" Identifier)?;
MatchWhen :: MatchWhenExpr | MatchDefault;
MatchWhenExpr :: #'when' #Sp BooleanExpr #"::" Statement*;
MatchDefault :: #"default" #"::" Statement*;

MatchStmtVariant :: #"match" #"(" MatchExpressions #")" #"{" MatchVariant+ #"}";
MatchVariant :: MatchVariantExpr | MatchDefault;
MatchVariantExpr :: #"|" MatchVariantConstructor #"::" Statement*;
MatchVariantConstructor :: Identifier VariantIdTuple?;

VariableTypePair :: Identifier #":" TypeId;

Identifier :: /[a-zA-Z_][a-zA-Z0-9_]*/;
IdTuple :: #"(" Identifier (#"," Identifier)* #")";
VariantIdTuple :: #"(" VariantSubType (#"," VariantSubType)* #")";

TypeId :: ChanType
        | BasicType
        | ArrayType
        | SetType
        | HashType
        | UserType
        ;
ChanType :: #"chan" TemplateInstantiation;
ArrayType :: (PointerDecl | DynArrayDecl) TypeId;
PointerDecl :: #"*";
DynArrayDecl :: #"[" #"]";
SetType :: #"<" #">" BasicType;
HashType :: #"[" BasicType #"]" TypeId;
TypeTuple :: #"(" TypeId (#"," TypeId)* #")";
UserType :: Identifier TemplateInstantiation?;
BasicType :: "long"
           | "int"
           | "short"
           | "byte"
           | "float"
           | "double"
           | "char"
           | "bool"
           | "string"
           ;

TemplateInstantiation :: #"!" TemplateParam;
TemplateParam :: TemplateParamList | TypeId;
TemplateParamList :: #"(" TypeId (#"," TypeId)* #")";
TemplateTypeParams :: TemplateTypeParamList?;
TemplateTypeParamList :: #"(" Identifier (#"," Identifier)* #")";
