Program :: ( Variant
           | StructDef
           | FuncDef
           )+
           ;

Sp :: /\s+/;

StructDef :: #'struct' #Sp StructId TemplateParamList?
             #"{" (StructEntry | StructFunction)+ #"}";
StructId :: Identifier;
StructEntry :: VariableTypePair #";";
StructFunction :: FuncDef;

FuncDef :: #'func' #Sp FuncId FuncDefArgList FuncReturnType FuncBodyBlocks;
FuncId :: Identifier;
FuncDefArgList :: #"(" (FuncSigArg (#"," FuncSigArg)*)? #")";
FuncSigArg :: VariableId #":" StorageClass* TypeId;
FuncReturnType :: (#":" (TypeId | TypeTuple))?;
FuncBodyBlocks :: ( BareBlock
                  | (InBlock? OutBlock? ReturnModBlock? BodyBlock)
                  );
InBlock :: #"in" BareBlock;
OutBlock :: #"out" BareBlock;
ReturnModBlock :: #'return' ((#Sp Identifier) | (#"" IdTuple)) BareBlock;
BodyBlock :: #"body" BareBlock;

BareBlock :: #"{" Statement* #"}";

StorageClass :: OutClass
              | InClass
              | ConstClass
              ;
OutClass :: #'out' #Sp;
InClass :: #'in' #Sp;
ConstClass :: #'const' #Sp;

Variant :: #'variant' #Sp VariantId TemplateParamList? #"{" VariantEntry+ #";"? #"}";
VariantId :: Identifier;
VariantEntry :: #"|" TagId VariantVarDeclList? #","?;
TagId :: Identifier;
VariantVarDeclList :: #'is' #Sp VariableTypePair (#"," VariableTypePair)*;

Statement :: BareBlock
           | FuncDef
           | ReturnStmt
           | MatchStmt
           | IfStmt
           | WhileStmt
           | ForStmt
           | ForeachStmt
           | Declaration
           | SpawnStmt
           | YieldStmt
           | ChanWrite
           | ChanReadStmt
           | DeclTypeInfer
           | ExprStmt
           ;

ReturnStmt :: #'return' #Sp Expr #";";

IfStmt :: #"if" #"(" BoolExpr #")" BareBlock (ElseIfStmt)* ElseStmt?;
ElseIfStmt :: #'else' #Sp #"if" #"(" BoolExpr #")" BareBlock;
ElseStmt :: #"else" BareBlock;

WhileStmt :: #"while" #"(" BoolExpr #")" BareBlock;

ForStmt :: #"for" #"(" ForInit BoolExpr #";" Expr #")" #"{" Statement* #"}";
ForInit :: DeclTypeInfer | DeclAssignment | AssignmentStmt;

ForeachStmt :: #"foreach" #"(" (Foreach2 | Foreach1) #";" Expr #")" #"{" Statement* #"}";
Foreach1 :: VariableId;
Foreach2 :: VariableId #"," VariableId;

DeclAssignment :: VariableTypePair #"=" Expr #";";
DeclTypeInfer :: VariableId #":=" Expr #";";
AssignmentStmt :: VariableId #"=" Expr #";";

Declaration :: VariableTypePair #";";

SpawnStmt :: #'spawn' #Sp FuncCall #";";

YieldStmt :: #'yield' #Sp #";";

ChanWrite :: ChanId #"<-=" Expr #";";
ChanId :: Identifier;

ChanReadStmt :: VariableId ChanRead #";";

FuncCallComplex :: MemberAccesses? FuncCall;
FuncCall :: FuncId #"(" (Expr (#"," Expr)*)? #")";
MemberAccesses :: MemberAccess+;
MemberAccess :: (FuncCall | Number | VariableId | ParenExpr) #".";

BoolExpr :: TrueExpr | FalseExpr | Expr;
TrueExpr :: #"true";
FalseExpr :: #"false";

ParenExpr :: #"(" Expr #")";
ExprStmt :: Expr #";";
Expr :: FuncCallComplex
      | ChanRead
      | Sum
      ;

MatchStmt :: #"match" #"(" Expr #")" #"{" MatchCase+ #"}";
MatchCase :: ( MatchIs
             | StringMatch
             | ^RangeMatch
             | CharMatch
             | NumMatch
             ) #":" Statement;
RangeMatch :: NumRangeMatch
            | CharRangeMatch
            ;
MatchIs :: VariantId (#'is' #Sp #"(" Identifier (#"," Identifier)* #")")?;
CharMatch :: CharLit;
StringMatch :: StringLit;
NumMatch :: Number;
NumRangeMatch :: Number #".." Number;
CharRangeMatch :: CharLit #".." CharLit;

VariableTypePair :: VariableId #":" TypeId;
VariableId :: Identifier;

ChanRead :: #"<-" ChanId;

Sum :: Product (SumOp Product)*;
Product :: Value (MulOp Value)*;
Value :: Number
       | VariableId
       ;

SumOp :: /[+-]/;
MulOp :: /[*\/%]/;

Number :: FloatNum | IntNum;
CharLit :: /'(?:\\n|\\t|\\r|[^\\])'/;
StringLit :: /"(?:\\.|[^"\\])*"/;
IntNum :: /-?[1-9][0-9]*|0/;
FloatNum :: /-?[0-9]+\.[0-9]+/;

Identifier :: /[a-zA-Z_][a-zA-Z0-9_]*/;
IdTuple :: #"(" Identifier (#"," Identifier)* #")";

TypeId :: ChanType
        | BasicType
        | ArrayType
        | SetType
        | HashType
        | TypeTuple
        | UserType
        ;
ChanType :: #"chan" TemplateInstantiation;
ArrayType :: (PointerDecl | DynArrayDecl)+ (BasicType | TypeTuple | UserType);
PointerDecl :: #"*";
DynArrayDecl :: #"[" #"]";
SetType :: #"<" #">" BasicType;
HashType :: #"[" BasicType #"]" TypeId;
TypeTuple :: #"(" TypeId (#"," TypeId)* #")";
UserType :: Identifier TemplateInstantiation?;
BasicType :: Int32
           | BoolType
           | Int16
           | Int8
           | CharType
           | Int64
           | FloatType
           | DoubleType
           ;
Int64       :: #"int64"   | #"long";
Int32       :: #"int32"   | #"int";
Int16       :: #"int16"   | #"short";
Int8        :: #"int8"    | #"byte";
FloatType   :: #"float32" | #"float";
DoubleType  :: #"float64" | #"double";
CharType    :: #"char";
BoolType    :: #"bool";

TemplateInstantiation :: #"!" TemplateParam;
TemplateParam :: TemplateParamList | TemplateParamSingle;
TemplateParamList :: #"(" TemplateId (#"," TemplateId)* #")";
TemplateParamSingle :: TemplateId;
TemplateId :: TypeId;
